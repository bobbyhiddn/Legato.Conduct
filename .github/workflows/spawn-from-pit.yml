name: Spawn Agent from Pit

on:
  repository_dispatch:
    types: [spawn-agent]

permissions:
  contents: write

jobs:
  spawn:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate payload
        id: validate
        run: |
          echo "Queue ID: ${{ github.event.client_payload.queue_id }}"
          echo "Project: ${{ github.event.client_payload.project_name }}"
          echo "Type: ${{ github.event.client_payload.project_type }}"
          echo "Target Repo: ${{ github.event.client_payload.target_repo }}"
          echo "Issue Title: ${{ github.event.client_payload.issue_title }}"

          # Determine if this is targeting an existing chord
          if [ -n "${{ github.event.client_payload.target_repo }}" ]; then
            echo "Mode: Spawning incident to existing chord"
            echo "spawn_mode=existing" >> $GITHUB_OUTPUT
          else
            echo "Mode: Creating new project"
            echo "spawn_mode=new" >> $GITHUB_OUTPUT
          fi

      - name: Create repository from template
        if: steps.validate.outputs.spawn_mode == 'new'
        env:
          GH_TOKEN: ${{ secrets.LAB_PAT }}
          PROJECT_NAME: ${{ github.event.client_payload.project_name }}
          PROJECT_TYPE: ${{ github.event.client_payload.project_type }}
        run: |
          REPO_ORG=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f1)

          # Determine suffix based on project type
          if [ "${PROJECT_TYPE}" = "note" ]; then
            SUFFIX="Note"
          else
            SUFFIX="Chord"
          fi

          NEW_REPO="${REPO_ORG}/${PROJECT_NAME}.${SUFFIX}"

          # Check if repo already exists (idempotent)
          if gh repo view "${NEW_REPO}" &>/dev/null; then
            echo "Repository ${NEW_REPO} already exists, skipping creation"
          else
            echo "Creating repository: ${NEW_REPO}"

            # Create the repository with README to ensure main branch exists
            gh repo create "${NEW_REPO}" \
              --public \
              --add-readme \
              --description "LEGATO project: ${PROJECT_NAME}"

            # Add topic tags for discoverability
            gh repo edit "${NEW_REPO}" --add-topic "legato-lab" --add-topic "legato-chord"
          fi

          # Clone the repo
          gh repo clone "${NEW_REPO}" project-clone
          cd project-clone

          # Configure git identity for commits
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Configure git to use GitHub CLI for authentication
          gh auth setup-git

          # Copy template files if they exist
          if [ -d "../templates/${PROJECT_TYPE}" ]; then
            cp -r "../templates/${PROJECT_TYPE}/." .
          fi

          # Commit template files if there are changes
          git add .
          if git diff --cached --quiet; then
            echo "No template changes to commit"
          else
            git commit -m "Initialize ${PROJECT_NAME} from LEGATO template"
            git push
          fi

      - name: Write SIGNAL.md
        if: steps.validate.outputs.spawn_mode == 'new'
        env:
          GH_TOKEN: ${{ secrets.LAB_PAT }}
          SIGNAL_JSON: ${{ toJson(github.event.client_payload.signal_json) }}
          PROJECT_NAME: ${{ github.event.client_payload.project_name }}
          PROJECT_TYPE: ${{ github.event.client_payload.project_type }}
        run: |
          REPO_ORG=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f1)

          if [ "${PROJECT_TYPE}" = "note" ]; then
            SUFFIX="Note"
          else
            SUFFIX="Chord"
          fi

          cd project-clone

          # Pull latest changes in case of rerun
          git pull --rebase origin main || true

          # Configure git identity and authentication
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          gh auth setup-git

          # Parse signal JSON and write SIGNAL.md
          cat > SIGNAL.md << 'SIGNAL_EOF'
          # Project Signal

          This project was spawned by LEGATO via Pit approval.

          ## Metadata
          - Queue ID: ${{ github.event.client_payload.queue_id }}
          - Project: ${{ github.event.client_payload.project_name }}
          - Type: ${{ github.event.client_payload.project_type }}
          SIGNAL_EOF

          # Commit SIGNAL.md if there are changes
          git add SIGNAL.md
          if git diff --cached --quiet; then
            echo "SIGNAL.md unchanged, skipping commit"
          else
            git commit -m "Add project signal metadata"
            git push
          fi

      - name: Create issue and assign to Copilot
        env:
          GH_TOKEN: ${{ secrets.LAB_PAT }}
          TASKER_BODY: ${{ github.event.client_payload.tasker_body }}
          PROJECT_NAME: ${{ github.event.client_payload.project_name }}
          PROJECT_TYPE: ${{ github.event.client_payload.project_type }}
          TARGET_REPO: ${{ github.event.client_payload.target_repo }}
          ISSUE_TITLE: ${{ github.event.client_payload.issue_title }}
          SPAWN_MODE: ${{ steps.validate.outputs.spawn_mode }}
        run: |
          DEFAULT_ORG=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f1)

          # Determine target repository and org
          if [ -n "${TARGET_REPO}" ]; then
            # Spawning to existing chord - extract org from target_repo
            REPO="${TARGET_REPO}"
            REPO_ORG=$(echo "${REPO}" | cut -d'/' -f1)
            REPO_NAME=$(echo "${REPO}" | cut -d'/' -f2)
            TITLE="${ISSUE_TITLE:-Incident}"
            LABELS="copilot,legato:incident"
            echo "Spawning incident to existing chord: ${REPO}"
          else
            # Creating new project - use default org
            REPO_ORG="${DEFAULT_ORG}"
            if [ "${PROJECT_TYPE}" = "note" ]; then
              SUFFIX="Note"
            else
              SUFFIX="Chord"
            fi
            REPO="${REPO_ORG}/${PROJECT_NAME}.${SUFFIX}"
            REPO_NAME="${PROJECT_NAME}.${SUFFIX}"
            TITLE="Initial Implementation"
            LABELS="copilot"
            echo "Creating initial issue in new project: ${REPO}"
          fi

          # Verify target repo exists (especially important for existing chord mode)
          if ! gh repo view "${REPO}" &>/dev/null; then
            echo "ERROR: Repository ${REPO} does not exist"
            exit 1
          fi

          # For existing chords, we always create a new issue (incidents are additive)
          # For new projects, check if "Initial Implementation" already exists (idempotent)
          if [ "${SPAWN_MODE}" = "new" ]; then
            EXISTING_ISSUE=$(gh api "/repos/${REPO}/issues?state=all" \
              -H "Accept: application/vnd.github+json" \
              --jq '.[] | select(.title == "Initial Implementation") | .number' | head -1)

            if [ -n "${EXISTING_ISSUE}" ]; then
              echo "Issue 'Initial Implementation' already exists: #${EXISTING_ISSUE}"
              ISSUE_NUMBER="${EXISTING_ISSUE}"
              ISSUE_URL="https://github.com/${REPO}/issues/${ISSUE_NUMBER}"
            fi
          fi

          # Create issue if needed
          if [ -z "${ISSUE_NUMBER}" ]; then
            echo "Creating issue in ${REPO} using REST API..."

            # Create issue using REST API (auto-creates labels)
            ISSUE_RESPONSE=$(gh api "/repos/${REPO}/issues" \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              -f title="${TITLE}" \
              -f body="${TASKER_BODY}" \
              -f "labels[]=${LABELS%%,*}")

            # Add additional labels if present
            if [[ "${LABELS}" == *","* ]]; then
              SECOND_LABEL="${LABELS#*,}"
              gh api "/repos/${REPO}/issues/$(echo "${ISSUE_RESPONSE}" | jq -r '.number')/labels" \
                -X POST \
                -H "Accept: application/vnd.github+json" \
                -f "labels[]=${SECOND_LABEL}" || true
            fi

            ISSUE_NUMBER=$(echo "${ISSUE_RESPONSE}" | jq -r '.number')
            ISSUE_URL=$(echo "${ISSUE_RESPONSE}" | jq -r '.html_url')

            echo "Issue created: #${ISSUE_NUMBER} - ${ISSUE_URL}"
          fi

          # Wait for GitHub to fully process the issue
          sleep 2

          # Get issue node ID for GraphQL
          echo "Getting issue GraphQL ID..."
          ISSUE_ID=$(gh api graphql -f query='
            query($owner: String!, $repo: String!, $number: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $number) {
                  id
                }
              }
            }
          ' -f owner="${REPO_ORG}" -f repo="${REPO_NAME}" -F number="${ISSUE_NUMBER}" --jq '.data.repository.issue.id')

          if [ -z "${ISSUE_ID}" ] || [ "${ISSUE_ID}" = "null" ]; then
            echo "ERROR: Could not get issue GraphQL ID"
            exit 1
          fi

          echo "Issue GraphQL ID: ${ISSUE_ID}"

          # Get Copilot actor ID from repository suggestedActors
          echo "Finding Copilot in suggested actors..."
          COPILOT_ID=$(gh api graphql -f query='
            query($owner: String!, $repo: String!) {
              repository(owner: $owner, name: $repo) {
                suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                  nodes {
                    login
                    ... on Bot { id }
                    ... on User { id }
                  }
                }
              }
            }
          ' -f owner="${REPO_ORG}" -f repo="${REPO_NAME}" --jq '.data.repository.suggestedActors.nodes[] | select(.login == "copilot-swe-agent") | .id')

          if [ -z "${COPILOT_ID}" ] || [ "${COPILOT_ID}" = "null" ]; then
            echo "ERROR: Copilot (copilot-swe-agent) not available as assignee"
            echo "Make sure Copilot coding agent is enabled for this repo/org"
            exit 1
          fi

          echo "Copilot ID: ${COPILOT_ID}"

          # Assign to Copilot using GraphQL - pipe full JSON request
          echo "Assigning issue to Copilot..."
          ASSIGN_RESULT=$(jq -n \
            --arg issueId "${ISSUE_ID}" \
            --arg copilotId "${COPILOT_ID}" \
            '{
              query: "mutation AssignToCopilot($issueId: ID!, $actorIds: [ID!]!) { replaceActorsForAssignable(input: { assignableId: $issueId, actorIds: $actorIds }) { assignable { ... on Issue { assignees(first: 5) { nodes { login } } } } } }",
              variables: {
                issueId: $issueId,
                actorIds: [$copilotId]
              }
            }' | gh api graphql --input -)

          # Verify assignment
          ASSIGNEES=$(echo "${ASSIGN_RESULT}" | jq -r '.data.replaceActorsForAssignable.assignable.assignees.nodes[].login' 2>/dev/null || echo "")

          if echo "${ASSIGNEES}" | grep -q "copilot"; then
            echo "SUCCESS: Issue assigned to Copilot"
            echo "Assignees: ${ASSIGNEES}"
          else
            echo "WARNING: Assignment may have failed"
            echo "Response: ${ASSIGN_RESULT}"
          fi
