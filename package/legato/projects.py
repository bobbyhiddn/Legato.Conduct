"""
LEGATO Projects Module.

Handles spawning Lab repositories and creating issues for Copilot.
"""

import os
import sys
import json
import argparse
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional

from .classifier import ClassifiedThread, ThreadType, ProjectScope


@dataclass
class ProjectSpec:
    """Specification for a Lab project."""

    name: str
    scope: ProjectScope
    title: str
    description: str
    domain_tags: list = field(default_factory=list)
    key_phrases: list = field(default_factory=list)
    source_transcript: Optional[str] = None
    created: Optional[str] = None
    tasker_body: Optional[str] = None

    def get_repo_name(self, org: str = "Legato") -> str:
        """Get the full repository name."""
        suffix = "Note" if self.scope == ProjectScope.NOTE else "Chord"
        return f"{org}/Lab.{self.name}.{suffix}"

    def to_signal(self) -> dict:
        """Convert to signal format for Listen."""
        return {
            "id": f"lab.{self.scope.value}.{self.name}",
            "type": "project",
            "source": "lab",
            "category": self.scope.value,
            "title": self.title,
            "domain_tags": self.domain_tags,
            "intent": self.description[:200] if self.description else "",
            "key_phrases": self.key_phrases,
            "path": f"Lab.{self.name}.{'Note' if self.scope == ProjectScope.NOTE else 'Chord'}",
            "created": self.created or datetime.utcnow().isoformat() + "Z",
            "updated": datetime.utcnow().isoformat() + "Z",
        }


def load_prompt(prompt_name: str) -> str:
    """Load a prompt from the prompts directory."""
    prompts_dir = Path(__file__).parent.parent.parent / "prompts"
    prompt_file = prompts_dir / f"{prompt_name}.md"

    if prompt_file.exists():
        return prompt_file.read_text()

    raise FileNotFoundError(f"Prompt not found: {prompt_file}")


def call_claude(system_prompt: str, user_input: str) -> str:
    """Call Claude API with the given prompts."""
    try:
        import anthropic
    except ImportError:
        raise RuntimeError("anthropic package not installed")

    client = anthropic.Anthropic()

    message = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=4096,
        system=system_prompt,
        messages=[{"role": "user", "content": user_input}]
    )

    return message.content[0].text


def create_project(thread: ClassifiedThread) -> ProjectSpec:
    """
    Create a project specification from a classified thread.

    Args:
        thread: A classified thread with type PROJECT

    Returns:
        ProjectSpec ready for spawning
    """
    if thread.thread_type != ThreadType.PROJECT:
        raise ValueError(f"Thread {thread.id} is not a PROJECT thread")

    # Generate project plan
    planner_prompt = load_prompt("project-planner")
    tasker_template = load_prompt("tasker-template")

    input_data = {
        "thread_id": thread.id,
        "scope": thread.project_scope.value if thread.project_scope else "note",
        "name": thread.project_name or "unnamed-project",
        "title": thread.knowledge_title or "Untitled Project",
        "description": thread.project_description or thread.raw_text,
        "domain_tags": thread.domain_tags,
        "key_phrases": thread.key_phrases,
        "source_id": thread.source_id,
        "text": thread.raw_text,
    }

    # Generate detailed plan
    plan_response = call_claude(planner_prompt, json.dumps(input_data, indent=2))

    # Generate tasker body
    tasker_input = {
        "title": input_data["title"],
        "context_from_transcript": thread.raw_text[:500],
        "correlation_context": "",
        "clear_objective": thread.project_description or "Implement the project as described",
        "criteria": thread.key_phrases[:5],
        "transcript_id": thread.source_id or "unknown",
        "related_links": [],
        "correlation_score": int(thread.correlation_score * 100),
        "source_id": thread.source_id or "unknown",
    }

    tasker_body = f"""## Tasker: {input_data['title']}

### Context
From voice transcript {tasker_input['transcript_id']}:
"{tasker_input['context_from_transcript']}"

### Objective
{tasker_input['clear_objective']}

### Acceptance Criteria
{chr(10).join(f"- [ ] {c}" for c in tasker_input['criteria'])}

### Constraints
- Follow patterns in `copilot-instructions.md`
- Reference `SIGNAL.md` for project intent
- Write tests for new functionality
- Keep PRs focused and reviewable

### References
- Source transcript: `{tasker_input['transcript_id']}`

---
*Generated by Legato.Conduct | Correlation: {tasker_input['correlation_score']}% | Source: {tasker_input['source_id']}*
"""

    return ProjectSpec(
        name=thread.project_name or "unnamed-project",
        scope=thread.project_scope or ProjectScope.NOTE,
        title=thread.knowledge_title or "Untitled Project",
        description=thread.project_description or thread.raw_text,
        domain_tags=thread.domain_tags,
        key_phrases=thread.key_phrases,
        source_transcript=thread.source_id,
        created=datetime.utcnow().isoformat() + "Z",
        tasker_body=tasker_body,
    )


def spawn_lab_repo(spec: ProjectSpec, org: str = None) -> dict:
    """
    Spawn a new Lab repository from template.

    Args:
        spec: Project specification
        org: GitHub organization (defaults to LAB_ORG env var or 'Legato')

    Returns:
        Repository creation result
    """
    token = os.environ.get("GH_TOKEN")
    if not token:
        raise RuntimeError("GH_TOKEN environment variable not set")

    # Get org from parameter, env var, or default
    org = org or os.environ.get("LAB_ORG", "Legato")

    repo_name = spec.get_repo_name(org)
    template_type = "note" if spec.scope == ProjectScope.NOTE else "chord"

    # Create repository
    create_cmd = [
        "gh", "repo", "create", repo_name,
        "--public",
        "--description", f"LEGATO project: {spec.title}"
    ]

    result = subprocess.run(create_cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"Failed to create repo: {result.stderr}")

    # Clone and set up
    subprocess.run(["gh", "repo", "clone", repo_name, "temp-clone"], check=True)

    # Copy template files
    template_dir = Path(__file__).parent.parent.parent / "templates" / template_type
    if template_dir.exists():
        import shutil
        for item in template_dir.iterdir():
            if item.name != ".git":
                dest = Path("temp-clone") / item.name
                if item.is_dir():
                    shutil.copytree(item, dest)
                else:
                    shutil.copy2(item, dest)

    # Write SIGNAL.md
    signal_content = f"""# {spec.title}

## Intent
{spec.description}

## Domain Tags
{', '.join(spec.domain_tags)}

## Key Phrases
{', '.join(spec.key_phrases)}

## Source
- Transcript: {spec.source_transcript or 'N/A'}
- Created: {spec.created}
"""

    (Path("temp-clone") / "SIGNAL.md").write_text(signal_content)

    # Commit and push
    os.chdir("temp-clone")
    subprocess.run(["git", "add", "."], check=True)
    subprocess.run(["git", "commit", "-m", f"Initialize from LEGATO template"], check=True)
    subprocess.run(["git", "push"], check=True)
    os.chdir("..")

    # Clean up
    import shutil
    shutil.rmtree("temp-clone")

    return {
        "repo": repo_name,
        "created": True,
        "template": template_type
    }


def create_issue_and_assign(spec: ProjectSpec, org: str = "Legato") -> dict:
    """
    Create an issue and assign to Copilot.

    Args:
        spec: Project specification
        org: GitHub organization

    Returns:
        Issue creation result
    """
    repo_name = spec.get_repo_name(org)

    # Create issue
    create_cmd = [
        "gh", "issue", "create",
        "--repo", repo_name,
        "--title", "Initial Implementation",
        "--body", spec.tasker_body or "Implement the project",
        "--label", "copilot-task,legato:spawned"
    ]

    result = subprocess.run(create_cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"Failed to create issue: {result.stderr}")

    issue_url = result.stdout.strip()
    issue_number = int(issue_url.split("/")[-1])

    # Assign to Copilot
    scripts_dir = Path(__file__).parent.parent.parent / "scripts"
    assign_script = scripts_dir / "assign_copilot.py"

    if assign_script.exists():
        subprocess.run([
            sys.executable, str(assign_script),
            "--repo", repo_name,
            "--issue", str(issue_number)
        ], check=True)

    return {
        "repo": repo_name,
        "issue_number": issue_number,
        "issue_url": issue_url,
        "assigned": True
    }


def process_routing(routing_file: str, spawn_and_assign: bool = False) -> list[dict]:
    """
    Process all PROJECT items from a routing file.

    Args:
        routing_file: Path to routing.json
        spawn_and_assign: Whether to actually spawn repos and assign

    Returns:
        List of results
    """
    with open(routing_file) as f:
        routing = json.load(f)

    results = []

    for item in routing:
        if item.get("type") != "PROJECT":
            continue

        thread = ClassifiedThread.from_dict(item)

        try:
            spec = create_project(thread)

            if spawn_and_assign:
                # Spawn repository
                spawn_result = spawn_lab_repo(spec)

                # Create issue and assign
                issue_result = create_issue_and_assign(spec)

                result = {**spawn_result, **issue_result, "project_name": spec.name}
            else:
                result = {
                    "project_name": spec.name,
                    "repo": spec.get_repo_name(),
                    "scope": spec.scope.value,
                    "action": "would_create"
                }

            results.append(result)
            print(f"Processed: {spec.name}")

        except Exception as e:
            print(f"Error processing {thread.id}: {e}", file=sys.stderr)
            results.append({"error": str(e), "thread_id": thread.id})

    return results


def main():
    """CLI entry point for projects module."""
    parser = argparse.ArgumentParser(description="LEGATO Projects Module")
    parser.add_argument(
        "--input",
        required=True,
        help="Input routing.json file"
    )
    parser.add_argument(
        "--spawn-and-assign",
        action="store_true",
        help="Actually spawn repos and assign to Copilot"
    )
    parser.add_argument(
        "--output",
        help="Output results file"
    )
    args = parser.parse_args()

    results = process_routing(args.input, args.spawn_and_assign)

    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)

    spawned = len([r for r in results if r.get("created")])
    errors = len([r for r in results if "error" in r])

    print(f"Processed {len(results)} projects: {spawned} spawned, {errors} errors")


if __name__ == "__main__":
    main()
